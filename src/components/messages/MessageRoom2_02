import React, { useEffect, useRef, useState, useLayoutEffect } from 'react';
import { Link } from 'react-router-dom';
import { buildStorageUrl } from '../../utility/GetUseImage';
import type { MatchUser } from '../../types/match';
import { ThreeDotsVertical, X, SendFill, Image } from 'react-bootstrap-icons';
import { useAuth } from '../../contexts/AuthContext';
import { firestore } from '../../firebaseConfig';
import {
  collection,
  query,
  orderBy,
  startAfter,
  limit,
  getDocs,
  addDoc,
  doc,
  updateDoc,
  serverTimestamp,
  DocumentData,
  QueryDocumentSnapshot,
} from 'firebase/firestore';
import {
  getStorage,
  ref as storageRef,
  uploadBytes,
  getDownloadURL,
} from 'firebase/storage';

/* debug */
let debug = process.env.REACT_APP_DEBUG;
if (debug === 'true') {
  console.log('[src/components/messages/MessageRoom2.tsx:xx] debug:', debug);
}

interface MessageRoom2Props {
  item: MatchUser;
  chatRoomId: string;
  latestMessage?: any;
  onClose: () => void;
}

const MessageRoom2 = ({
  item,
  chatRoomId,
  latestMessage,
  onClose,
}: MessageRoom2Props) => {
  const { currentUserProfile } = useAuth();
  const [showModal, setShowModal] = useState(false);
  const [showChatModal, setShowChatModal] = useState(false);

  const [messages, setMessages] = useState<DocumentData[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement | null>(null);
  const topObserverRef = useRef<HTMLDivElement | null>(null);
  const fetchedMessageIdsRef = useRef<Set<string>>(new Set());
  const initialLoadRef = useRef(true);
  const topMostDocRef = useRef<QueryDocumentSnapshot | null>(null);
  const chatBodyRef = useRef<HTMLDivElement | null>(null);
  const observerRef = useRef<IntersectionObserver | null>(null);
  const [messagesToolModal, setMessagesToolModal] = useState(false);
  const prevScrollHeightRef = useRef<number>(0);

  // 入力・送信状態
  const [inputText, setInputText] = useState('');
  const [isSending, setIsSending] = useState(false);

  // 画像プレビュー・選択ファイル
  const [previewImages, setPreviewImages] = useState<string[]>([]);
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);

  // 初回：最新30件だけを取得 → 古→新 の順にセット
  const fetchInitialMessages = async () => {
    if (!chatRoomId) return;
    fetchedMessageIdsRef.current.clear();
    setIsLoading(true);
    const snap = await getDocs(
      query(
        collection(firestore, `chats/${chatRoomId}/messages`),
        orderBy('created_at', 'desc'),
        limit(30)
      )
    );
    const docs = snap.docs.map((d) => d.data()).reverse();
    setMessages(docs);
    topMostDocRef.current = snap.docs[snap.docs.length - 1] || null;
    setIsLoading(false);
    snap.docs.forEach((d) => fetchedMessageIdsRef.current.add(d.id));
  };
  // 過去メッセージ取得
  const fetchMessages = async () => {
    if (!chatRoomId || isLoading) return;
    setIsLoading(true);
    const baseQ = query(
      collection(firestore, `chats/${chatRoomId}/messages`),
      orderBy('created_at', 'desc'),
      ...(topMostDocRef.current ? [startAfter(topMostDocRef.current)] : []),
      limit(30)
    );
    const snap = await getDocs(baseQ);
    const newDocs = snap.docs.filter(
      (d) => !fetchedMessageIdsRef.current.has(d.id)
    );
    newDocs.forEach((d) => fetchedMessageIdsRef.current.add(d.id));
    const newMsgs = newDocs.map((d) => d.data());
    setMessages((prev) => [...newMsgs.reverse(), ...prev]);
    if (snap.docs.length > 0) {
      topMostDocRef.current = snap.docs[snap.docs.length - 1];
    }
    setIsLoading(false);
  };

  useEffect(() => {
    fetchInitialMessages();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chatRoomId]);

  useLayoutEffect(() => {
    if (
      showChatModal &&
      initialLoadRef.current &&
      messages.length > 0 &&
      chatBodyRef.current
    ) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight;
      initialLoadRef.current = false;
    }
  }, [showChatModal, messages]);

  /** メッセージ送信 */
  const handleSend = async () => {
    const text = inputText.trim();
    if (!chatRoomId || (text === '' && selectedFiles.length === 0)) return;
    setIsSending(true);
    try {
      // 1) Firestore に空 images で登録
      const msgRef = await addDoc(
        collection(firestore, `chats/${chatRoomId}/messages`),
        {
          sender_id: currentUserProfile?.user_profile?.uid,
          text,
          images: [],
          is_deleted: false,
          last_read_at: {},
          created_at: serverTimestamp(),
        }
      );
      // 2) 画像アップロード＆URL取得
      let imageObjects: Array<{
        original: string;
        thumb: string;
        aspect: number;
      }> = [];
      if (selectedFiles.length > 0) {
        const storage = getStorage();
        imageObjects = await Promise.all(
          selectedFiles.map(async (file) => {
            const basePath = `chats/${chatRoomId}/messages/${msgRef.id}`;
            const origPath = `${basePath}/original/${file.name}`;
            const thumbPath = `${basePath}/thumb/${file.name}`;
            const origRef = storageRef(storage, origPath);
            const thumbRef = storageRef(storage, thumbPath);
            await uploadBytes(origRef, file);
            await uploadBytes(thumbRef, file);
            const [originalUrl, thumbUrl] = await Promise.all([
              getDownloadURL(origRef),
              getDownloadURL(thumbRef),
            ]);
            const imgEl = await new Promise<HTMLImageElement>((res) => {
              const img = document.createElement('img');
              img.onload = () => res(img);
              img.src = originalUrl;
            });
            return {
              original: originalUrl,
              thumb: thumbUrl,
              aspect: imgEl.width / imgEl.height,
            };
          })
        );
        await updateDoc(msgRef, { images: imageObjects });
      }
      // 3) ルーム updated_at
      await updateDoc(doc(firestore, 'chats', chatRoomId), {
        updated_at: serverTimestamp(),
      });
      // 4) ローカル state
      setMessages((prev) => [
        ...prev,
        {
          sender_id: currentUserProfile?.user_profile?.uid,
          text,
          images: imageObjects,
          is_deleted: false,
          last_read_at: {},
          created_at: { seconds: Math.floor(Date.now() / 1000) },
        },
      ]);
      setSelectedFiles([]);
      setPreviewImages([]);
    } catch (error) {
      console.error('メッセージ送信中にエラー:', error);
    } finally {
      setIsSending(false);
      setInputText('');
    }
  };

  // 無限スクロール
  useEffect(() => {
    if (!showChatModal) return;
    const container = chatBodyRef.current;
    const sentinel = topObserverRef.current;
    if (!container || !sentinel) return;
    observerRef.current?.disconnect();
    observerRef.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && !isLoading && topMostDocRef.current) {
          prevScrollHeightRef.current = container.scrollHeight;
          fetchMessages();
        }
      },
      { root: container, rootMargin: '0px', threshold: 0 }
    );
    observerRef.current.observe(sentinel);
    return () => observerRef.current?.disconnect();
  }, [showChatModal]);

  // スクロール位置キープ
  useLayoutEffect(() => {
    if (
      !initialLoadRef.current &&
      prevScrollHeightRef.current &&
      chatBodyRef.current
    ) {
      const c = chatBodyRef.current;
      c.scrollTop = c.scrollHeight - prevScrollHeightRef.current;
      prevScrollHeightRef.current = 0;
    }
  }, [messages]);

  /** 画像選択時の preview とファイル保持 */
  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files ?? []).slice(0, 5);
    // 既存分と合わせて最大5枚まで
    const combined = [...selectedFiles, ...files].slice(0, 5); // ← 変更
    setSelectedFiles(combined);
    // プレビューは URL.createObjectURL でまとめて生成
    const urls = combined.map((f) => URL.createObjectURL(f)); // ← 変更
    setPreviewImages(urls);
  };

  return <>{/* ... 以下 JSX 部分は省略せず上記と同じです ... */}</>;
};

export default MessageRoom2;
